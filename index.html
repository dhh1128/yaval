<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>yaval by dhh1128</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/main.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>

      <header>
        <h1>yaval</h1>
        <p>yaml schema language and validator</p>
      </header>

      <div id="banner">
        <span id="logo"></span>

        <a href="https://github.com/dhh1128/yaval" class="button fork"><strong>View On GitHub</strong></a>
        <div class="downloads">
          <span>Downloads:</span>
          <ul>
            <li><a href="https://github.com/dhh1128/yaval/zipball/master" class="button">ZIP</a></li>
            <li><a href="https://github.com/dhh1128/yaval/tarball/master" class="button">TAR</a></li>
          </ul>
        </div>
      </div><!-- end banner -->

    <div class="wrapper">
      <nav>
        <ul></ul>
      </nav>
      <section>
        <h3>
<a id="about" class="anchor" href="#about" aria-hidden="true">
<span aria-hidden="true" class="octicon octicon-link"></span></a>Validate the structure of your YAML</h3>

<p>Yaval (short for "YAML Validator", rhymes with "gravel") is a schema language for yaml--and it's
a tool that validates documents against such schemas. Yaval schemas are written in--what else?--yaml.
If you already know yaml, you can learn the basics of yaval schemas in 5 minutes. Here's a schema for
a shopping list, to give you a taste:</p>

<pre>
shopping_list: {items: {fields: [{count: int}, {descrip: str}]}}
</pre>

<p>This schema says that shopping_list documents contain zero or more tuples consisting of two
fields, where the first field is an integer named "count" and the second field is a string
named "descrip". Like this:
</p>

<pre>
- [3, '10-oz cans tomato sauce']
- [1, 'gallon 2% milk']
</pre>

<p>Of course, you can describe much fancier structures, and you can constrain what they contain
in many powerful ways. The <a href="tutorial.html">tutorial</a> has details.</p>

<h3>
  <a id="tool" class="anchor" href="#tool" aria-hidden="true">
  <span aria-hidden="true" class="octicon octicon-link"></span></a>Tool</h3>
<p>To validate a document against a yaval schema, clone or pull the yaval source
from github (or download the zip/tarball; see buttons above) and add
<em style="color: purple">&lt;your local yaval git repo&gt;</em> to the path.
You must also have PyYAML installed in your python env (<code>pip install PyYAML</code>).
If you're on OSX/*nix, make sure the yaval script is executable. Then:</p>

<pre>yaval <em style="color: gold">&lt;path to my schema&gt;</em> <em style="color: gold">&lt;path to my doc&gt;</em></pre>

<p>The tool will print useful errors and exit with code 1 if it finds conformance problems, or
silently exit with code 0 on success. It supports options for verbose mode and so forth; try
<code>yaval --help</code> to explore.</p>

<h3>
  <a id="others" class="anchor" href="#others" aria-hidden="true">
  <span aria-hidden="true" class="octicon octicon-link"></span></a>Comparison with other schema languages</h3>
<p>Yaval is inspired by the <a href="http://json-schema.org" target="external">json-schema</a> project; when yaval schemas are
expressed in the json-compatible yaml flow style, they resemble json-schema quite a bit. All the richness of
json-schema constraints is possible in yaval. Yaval also draws on some <a href="http://pyyaml.org/wiki/SchemaProposalYGNI"
target="external">musings from Ingy d√∂t Net</a>, and from the <a href="http://www.kuwata-lab.com/kwalify/"
target="external">kwalify project</a>.</p>

<p>Research for yaval contemplated ideas from <a href="https://developers.google.com/protocol-buffers/"
target="external">Google Protocol Buffers</a>, <a href="https://capnproto.org/"
target="external">Cap'n Proto</a>, and <a href="https://avro.apache.org/" target="external">Apache Avro</a>.
In addition, I have a background in <a href="https://en.wikipedia.org/wiki/Document_type_definition"
target="external">DTD</a> creation for ISO standards, as well as <a href="https://www.w3.org/standards/xml/schema"
target="external">XSD</a>, and I have tangled with <a href="https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One"
target="external">ASN.1</a> and <a href="https://en.wikipedia.org/wiki/Formal_grammar" target="external">formal
grammars</a> a time or two. All of these probably influenced the design.</p>

<p>Yaval is entirely unique in its ability to encode the semantic richness called for in the <em>lacuna
humana</em> series of <a href="https://codecraft.co/2014/07/16/lacunas-everywhere/" target="external">
posts on codecraft.co</a>. <a href="lacuna.html">This feature</a>, plus the desire to provide a <a href="api.html">python API</a>
for the schema validator and the desire to simplify some clumsy syntax in other solutions, motivated an
independent course for yaval.</p>

<p>If you are ruby-centric and have a need to validate both json and yaml, kwalify may be a simpler
choice. If you are very json-centric and yaml is just a corner case, you may get what you want from
json-schema. But if you're invested in yaml and you want simplicity, power, and a python API--or if
you want to use your yaml docs for <a href="lacuna.html"><em>lacuna human</em> use cases</a>, yaval
is an excellent choice.
</p>

<h3>
  <a id="contributing" class="anchor" href="#contributing" aria-hidden="true">
  <span aria-hidden="true" class="octicon octicon-link"></span></a>Contributing</h3>
<p>I'd love to get bug fixes, new sample schemas, and additional unit tests. Just open a pull request
and we'll see if your elbow grease can benefit everyone. (I'm pragmatic rather than
fussy, but new code should generally match the conventions and assumptions in the
original codebase. In particular, I want to retain python 2.x compatibility for now.)</p>
<p>I'm interested in adding a C++ API (using <a href="https://github.com/jbeder/yaml-cpp"
target="external">yaml-cpp</a>) and maybe a java API as well; if you want to do that or
collaborate on it--or if you're interested in other ambitious contributions--feel
free to ping me at <span style="color:#405090">daniel <em>dot</em> hardman <em>at</em> gmail</span>.
</p>
      </section>
      <footer>
        <p><a href="index.html">Overview</a></p>
        <p><a href="tutorial.html">Tutorial</a></p>
        <p><a href="api.html">API</a></p>
        <p><a href="faq.html">FAQ</a></p>
        <p>Project maintained by <a href="https://github.com/dhh1128">dhh1128</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
